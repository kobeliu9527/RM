@inject IJSRuntime JSRuntime

<div class="container-wrapper">
    <div class="widget-wrapper">
        @for (int rowIndex = 0; rowIndex < ContainerData?.Rows.Count; rowIndex++)
        {
            var currentRowIndex = rowIndex;
            var currentRow = ContainerData.Rows[currentRowIndex];
            bool isMoveRowUpVisible = IsMoveRowUpVisible(currentRow);
            bool isMoveRowDownVisible = IsMoveRowDownVisible(currentRow);
            bool isRowElement = isMoveRowUpVisible ||
            isMoveRowDownVisible ||
            ContainerData?.Rows.Count > 0;
            string rowElementClass = isRowElement ? "row-element-runing" : "";
            string rowSeparatorClass = currentRowIndex == ContainerData.Rows.Count - 1 ?
            "row-separator" : "";

            <div class="row row-builder @rowElementClass @rowSeparatorClass">
                @for (int componentIndex = 0; componentIndex < currentRow.Count; componentIndex++)
                {
                    var currentComponentIndex = componentIndex;
                    var currentComponent = currentRow[componentIndex];
                    string componentColumnWidth =
                    ComponentUtils.GetComponentColumnCssClasses(currentComponent);
                    string h = "auto";
                    h = currentComponent?.Height <= 0 ? "auto" : currentComponent?.Height + "px";
                    @if (currentComponent.IsAbsPosition)
                    {
                        //z-index:@(currentComponent.Zindex)
                        <div class="draggable" style="position:absolute;top:@(currentComponent.Top)px;left:@(currentComponent.Left)px;width:@h;"
                             draggable="true">
                            <CascadingValue Value="this" Name="Container">
                                <ComponentRuning ComponentData="@currentComponent"
                                                 ComponentRow="@currentRow"
                                                 ComponentIndex="@currentComponentIndex" />
                            </CascadingValue>
                        </div>
                    }
                    else
                    {
                        <div class="draggable  @componentColumnWidth">
                            <ComponentRuning ComponentData="@currentComponent"
                                             ComponentRow="@currentRow"
                                             ComponentIndex="@currentComponentIndex" />
                        </div>

                    }

                }
            </div>
        }
    </div>
</div>

@code {
    [CascadingParameter(Name = "Root")]
    [NotNull]
    public FormRuning? Root { get; set; }
    /// <summary>
    /// 跟容器数据
    /// </summary>
    [Parameter]
    [NotNull]
    public ContainerDto? ContainerData { get; set; }

    private const string ComponentHighlighterCssClass = @"'component-element--hover'";
    private const string DropZoneCssClasses = @"'bo-dropzone-hover bo-drag-enter'";
    private const string DropZoneCssClassesWithoutSingleQuotes = @"bo-dropzone-hover bo-drag-enter";

    #region Move Row Up-Down Methods
    private bool IsMoveRowUpVisible(List<ComponentDto> componentsInRow)
    {
        return ContainerData.Rows.IsMoveLeftPossible(componentsInRow);
    }

    private bool IsMoveRowDownVisible(List<ComponentDto> componentsInRow)
    {
        return ContainerData.Rows.IsMoveRightPossible(componentsInRow);
    }

    private async Task MoveRowUpAsync(List<ComponentDto> componentsInRow)
    {
        ContainerData.Rows.MoveLeft(componentsInRow);
        await Task.CompletedTask;
    }

    private async Task MoveRowDownAsync(List<ComponentDto> componentsInRow)
    {
        ContainerData.Rows.MoveRight(componentsInRow);
        await Task.CompletedTask;
    }
    #endregion Move Row Up-Down Methods

    #region Drag and Drop Methods
    private async Task DragComponentStartAsync(ComponentDto draggedItemData,
        List<ComponentDto> currentRow, ContainerDto currentContainer)
    {
        await Root.SetDraggedComponentAsync(draggedItemData, currentRow, currentContainer);
    }
    /// <summary>
    /// 在拖动一行组件完成前
    /// </summary>
    /// <param name="rowIndex"></param>
    /// <param name="currentContainer"></param>
    /// <returns></returns>
    private async Task DropComponentBeforeRowAsync(int rowIndex,
        ContainerDto currentContainer)
    {
        var newRow = new List<ComponentDto>();
        currentContainer.Rows.Insert(rowIndex, newRow);

        await DropComponentToEndOfRowAsync(currentContainer, newRow);
    }

    private async Task DropComponentAfterRowAsync(int rowIndex,
        ContainerDto currentContainer)
    {
        var newRow = new List<ComponentDto>();
        var newRowIndex = rowIndex + 1;
        currentContainer.Rows.Insert(newRowIndex, newRow);

        await DropComponentToEndOfRowAsync(currentContainer, newRow);
    }
    /// <summary>
    /// 拖拽一行数据完成时候触发
    /// </summary>
    /// <param name="containerData"></param>
    /// <param name="destinationRow"></param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    private async Task DropComponentToEndOfRowAsync(ContainerDto containerData,
        List<ComponentDto> destinationRow)
    {
        if (Root.IsDraggedItemPaletteWidget())
        {
            // you are trying to drag and drop a new widget from Palette
            var paletteWidgetData = await Root.GetDraggedPaletteWidgetAsync();
            var newComponentData = paletteWidgetData.CreateComponent();
            newComponentData.ParentId = containerData.Id;
            await AddComponentToRowAsync(newComponentData, destinationRow);
            await Root.SelectComponentAsync(newComponentData);
        }
        else if (Root.IsDraggedItemComponent())
        {
            // you are trying to drag and drop a widget already defined in whiteboard
            var componentData = await Root.GetDraggedComponentDataAsync();
            var originRow = await Root.GetDraggedComponentOriginRowAsync();

            // de-attach widget from its previous position in origin row
            await DetachComponentFromPreviousRowAsync(componentData, originRow);

            // TODO: Check is component movable

            // add component to destination row
            await AddComponentToRowAsync(componentData, destinationRow);

            if (originRow.Count == 0)
            {
                var originContainer = await Root.GetDraggedComponentOriginContainerAsync();
                originContainer.Rows.Remove(originRow);
                originRow = null;
            }

            await Root.SelectComponentAsync(componentData);
        }
        else
        {
            throw new NotImplementedException();
        }
    }

    private async Task OnDropFinishedAsync(Guid elementId)
    {
        await JSRuntime.InvokeVoidAsync("formDesigner.utils.removeClassById",
            elementId, DropZoneCssClassesWithoutSingleQuotes);
    }
    #endregion Drag and Drop Methods

    #region Helper Methods

    /// <summary>
    /// 将组件添加到行中,并重新计算空间
    /// </summary>
    /// <param name="componentData"></param>
    /// <param name="currentRow"></param>
    /// <returns></returns>
    private async Task AddComponentToRowAsync(ComponentDto componentData,
        List<ComponentDto> currentRow)
    {
        currentRow.Add(componentData);
        ComponentUtils.ComputeEachItemSizeInRow(currentRow);
        await Task.CompletedTask;
    }

    private async Task DetachComponentFromPreviousRowAsync(ComponentDto componentData,
        List<ComponentDto> destinationRow)
    {
        var originRow = await Root.GetDraggedComponentOriginRowAsync();

        // remove component from origin row
        originRow.Remove(componentData);

        var originContainer = await Root.GetDraggedComponentOriginContainerAsync();

        if (destinationRow?.Count == 0 && destinationRow != originRow)
        {
            await originContainer.RemoveRowAsync(originRow);
        }

        if (originRow?.Count == 0 && destinationRow != originRow)
        {
            await originContainer.RemoveRowAsync(originRow);
        }

        await Root.SelectComponentAsync(null);
    }

    /// <summary>
    /// Returns the CSS column width that must be used by a component in the editor
    /// to reflect its width and the currently selected resolution.
    /// </summary>
    /// <param name="componentsInRow"></param>
    /// <returns></returns>
    private int CalculateRowSize(List<ComponentDto> componentsInRow)
    {
        int size = 0;

        foreach (var component in componentsInRow)
        {
            size += ComponentUtils.CalculateColumnWidth(component);
        }

        return size;
    }
    #endregion Helper Methods
}
